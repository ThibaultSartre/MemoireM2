\documentclass[a4paper,twoside,12pt,openright]{report}

%% Language %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[francais]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern} 
\usepackage{hyperref}
\usepackage{tabto}

%% Packages for Graphics & Figures %%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{graphicx} 

%% Math Packages %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{fullpage}

\setlength{\parindent}{0cm}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}
\newcommand{\hsp}{\hspace{20pt}}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% DOCUMENT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\begin{titlepage}
  \begin{sffamily}
  \begin{center}

    \textsc{\LARGE MASTER MIAGE 2ème année \linebreak Université Paris Nanterre}\\[2cm]

    \textsc{\Large Mémoire de fin d’études présenté pour l’obtention du grade de master}\\[1.5cm]

    \HRule \\[0.4cm]
    { \huge \bfseries Comment les flots de contrôle peuvent-ils nous permettre de faire du refactoring de code en Java. \\[0.4cm] }

    \HRule \\[2cm]
    \includegraphics[scale=0.40]{image/univ.jpg}
    \hspace{2cm}
    
    \vfill
  \begin{minipage}{0.4\textwidth}
      \begin{flushleft} \large
        \textsc{Présenté par :}\\ \textsc{Thibault Sartre}\\
      \end{flushleft}
    \end{minipage}
    \begin{minipage}{0.4\textwidth}
      \begin{flushright} \large
        \textsc{Tuteur :}\\ \textsc{Mcf. Emmanuel Hyon}\\
      \end{flushright}
    \end{minipage}
    \vfill
    {\large Septembre 2018 — Juillet 2019}
  \end{center}
  \end{sffamily}
\end{titlepage}
\renewcommand{\contentsname}{Sommaire}
\tableofcontents{}
\chapter{Contexte}
\section{Introduction}
Le refactoring est une activité d'ingénierie logiciel consistant à modifier le code source d'une application de manière à améliorer sa qualité sans altérer son comportement vis-à-vis des utilisateurs.
L'objectif du refactoring est de réduire les coûts de maintenance et de pérenniser les investissements tout au long du cycle de vie du logiciel en se concentrant sur la maintenabilité et l'évolutivité.\cite{ref1}\\
"With refactoring you can take a bad design, chaos even, and rework it into well-designed code."\cite{ref2}\\
Le refactoring permet donc de passer d'un code possédant de mauvaise base à un code propre.\\
Un bon refactoring doit pouvoir améliorer la qualité d'un code tout en gardant son fonctionnement du point de vue de l'utilisateur. Concernant la partie des tests, tout les tests qui fonctionnaient avant le refactoring se doivent d'être fonctionnels après.\\
Dans ce mémoire, nous allons d'abord étudier les problèmes dans les programmes qui mène au refactoring, ensuite on va analyser différentes techniques de refactoring. Puis nous allons étudier les outils de refactoring existant ainsi que les graphes de flot de contrôle.\\ Enfin on étudiera s'il est possible de faire du refactoring à l'aide des flots de contrôle pour le langage Java.\\
Ce sujet est intéressant et actuel car il faut commencer à ce soucier du code que l'on produit car plus l'on avance dans le temps plus les programmes sont lourds et contiennent de lignes de code. Avec la puissance des ordinateurs actuels, la plus part des développeurs ne prennent plus le temps d'écrire des codes de qualité car la machine sera de toute façon assez rapide pour compenser un code de mauvaise qualité.\cite{ref4}\\
Avec le temps, la relecture et la modification de code sera difficile avec les programmes qui deviennent de plus en plus gros.\cite{ref4}\\
Pour essayer de diminuer cette quantité de travail à l'avenir, il faut commencer à produire du code de qualité et bien structuré. Concernant les codes déjà existant il faudra donc faire du refactoring de code. Or le refactoring peut-être long selon la qualité des projets que l'on traite. Il serait donc intéressant et très utile d'avoir un programme permettant d'automatiser des parties de refactoring pour permettre de gagner du temps précieux. 
Ce mémoire a pour but de fournir une solution qui permettrais de faire du refactoring de code facilement pour gagner du temps tout en produisant du code de qualité.\cite{ref3}

\chapter{Pourquoi faire du refactoring ?}
Dans ce chapitre, je vais vous présenter la plus part des problèmes rencontré par les développeurs qui va les mener à faire du refactoring.\\


\section{Bloaters}
Les bloaters (ou ballonnement) sont des classes, méthodes ou même du simple code qui à pris des proportions énormes. Ce qui rend le travail dessus compliqué. Ce type de problème se développe au fil du temps si personne ne fait attention .\\

\subsection{Méthode trop longue}
\paragraph{Problème :}
Un des soucis que beaucoup de développeur possèdent, est qu'ils préfèrent rajouter des lignes de code dans une méthode existante plutôt que de créer une nouvelle méthode sous prétexte que cette nouvelle méthode ne ferait que quelques lignes.\\
Cela engrange des méthodes trop grosses et difficile à lire et à maintenir.\\

\paragraph{Gain du traitement :}
Le refactoring d'une méthode trop longue permet à cette même méthode de vivre plus longtemps du fait de sa simplicité.\\
Cela permet aussi en général de supprimer potentiellement une duplication de code.\\
Avec une méthode qui est maintenant petite et clair, il est alors beaucoup plus simple et rapide de la maintenir.\\

\subsection{Grande classe}
\paragraph{Problème :}
Un peu comme pour la méthode trop longue, on a tendance à préférer placer une nouvelle fonctionnalités dans une classe existante plutôt que de créer une nouvelle classe.\\
Ce qui en découle est une classe monstrueusement grande, ce qui la rend très difficilement praticable.\\

\paragraph{Gain du traitement :}
Une fois le refactoring effectué, le développeurs n'a plus à avoir en tête les dizaine et dizaine d'attributs et méthodes qui composent sa classe.\\
Et comme dit précédemment le découpage d'une classe va aussi en général permettre une suppression de doublon de code ou au moins le rendre moins apte à apparaître.\\

\subsection{L'obsession des types primitifs}
\paragraph{Problème :}
Les problèmes liés aux types primitifs sont :\\
- l'utilisation d'un simple type "string" pour un numéro de téléphone ou bien un "integer" pour représenter un montant d'argent à la place d'objet.\\
- l'utilisation de constante pour coder de l'information comme des droits administrateurs\\
- l'utilisation de chaîne de caractère en guise de noms de champs dans des tableaux de données.\\

\paragraph{Gain du traitement :}
On obtient un code plus flexible grâce à l'utilisation d'objet.\\
Plus besoin de se demander à quoi serve toutes ces constantes.\\
Globalement le code est plus compréhensible.\\

\subsection{Longue liste de paramètre}
\paragraph{Problème :}
On peut considérer qu'une liste de paramètre devient trop longue dès lors qu'elle contient plus de quatre paramètres.\\
Une longue liste de paramètre peut vouloir dire qu'une méthode est en faite la combinaison de plusieurs.\\
Ces listes sont difficile à comprendre, il est préférable d'utiliser les attributs de la classe où la méthode se trouve et si ce n'est pas possible alors il est préférable d'envoyer un objet qui regroupe les données nécessaires.\\

\paragraph{Gain du traitement :}
Le code devient plus lisible.\\
Il peut être raccourcie dans le cas où la méthode était une fusion de plusieurs.\\

\subsection{Agrégat de données}
\paragraph{Problème :}
Parfois il est possible de trouver des groupes de variable identique qui apparaissent à plusieurs endroit dans le code.\\
Ces agrégats sont souvent dû à de la programmation copié collé ou à une structure pauvre du programme.\\
Pour savoir s'il est possible d'extraire ces agrégat de données pour former une nouvelle classe, il faut vérifier si c'est bien le groupement de toutes ces données qui leurs donne du sens (par exemple les données nécessaires à la connections vers une base). Si c'est la cas, le choix de créer une nouvelle classe pour ces données est conseillé.\\

\paragraph{Gain du traitement :}
Permet de facilité la compréhension et l'organisation du code et surtout de ces agrégats de données puisque les opérations liées à ces données sont maintenant regroupés vers une seule classe.\\

\section{Abus du principe orientation objet}
Il s'agit de problème basé sur la mauvaise utilisation du principe de programmation "orienté objet".\\

\subsection{La structure switch}
\paragraph{Problème :}
Ce problème survient lorsque l'on obtient un "switch" ou une séquence de "if" complexe.\\
Les "switch" de ce type peuvent être utilisés pour faire un traitement différent selon le type d'un objet.\\
Par exemple, on a une classe Oiseau qui possède une méthode getSpeed(). Cette méthode va à l'aide d'un switch analyser un attribut qui définie qu'elle oiseau représente la classe pour renvoyer la vitesse de cette oiseau.\\
Dans ces cas là, il est préférable d'utiliser le polymorphisme (voir \textit{Remplacer les conditions avec du polymorphisme}).

\paragraph{Gain du traitement :}
On obtient une meilleure organisation du code.\\

\subsection{Héritage refusé}
\paragraph{Problème :}
Ici, le problème survient lorsque l'on commence à créer des sous classes uniquement pour ré-utiliser certaine méthode de la super classe alors que la super classe et la sous classe ne possèdent pas de réel lien.\\


\paragraph{Gain du traitement :}
En supprimant ces liens entre les classes, on obtient  un code plus organisé et clair.\\
On n'aura plus d'héritage "bizarre" qui n'ont aucun sens.\\

\section{Modification complexe}
Dans cette section, nous allons parler de problème lié a la modification difficile de code.\\
Par exemple lorsqu'on doit modifier du code à plein d'endroit différent pour faire fonctionner le tout.\\

\subsection{Changement Divergent}
\paragraph{Problème :}
Ce problème cible particulièrement le cas ou un simple changement dans une classe produit un grand nombre de changement dans d'autre méthode de cette même classe.\\
Par exemple dans le cas d'une classe produit, et qu'on veut rajouter un type de produit, il faut alors changer les méthodes de recherche, d'affichage et d'ordonnancement de produit.\\
Pour cette exemple, il faudrait utiliser la technique de refactoring d'extraction de classe.\\

\paragraph{Gain du traitement :}
Avec ce traitement, on simplifie la maintenance du code et on simplifie son organisation.\\

\subsection{Chirurgie au fusil}
\paragraph{Problème :}
Cette fois, on a un problème totalement inverse au précédent c'est à dire qu'ici un petit changement demande de faire des petits changement dans plusieurs classe.\\
On obtient ce problème dans le cas où une responsabilité de traitement est affecté à plusieurs classe et si ce traitement doit changer, toutes les classes doivent être modifiées.\\
Les refactoring utilisés pour réparer le code sont le "déplacement de méthode et d'attribut".\\

\paragraph{Gain du traitement :}
En revanche les avantages du traitement sont les mêmes que précédemment c'est à dire une meilleure organisation et une maintenance simplifiée.\\


\section{Les choses dispensables}
Lors de cette partie, nous allons parler de toutes les petites choses qui sont dans le code mais qui ne servent à rien.

\subsection{Les commentaires}
\paragraph{Problème :}
Attention je ne dis pas que les commentaires en générales sont inutiles.\\
Ici le problème est lorsque l'on utilise les commentaires pour masquer un code d'une qualité douteuse.\\
Dans ces cas la, les développeurs vont écrire du code très peu compréhensible au premier regard et le remplie de commentaire afin de tout expliquer.\\
Pour remédier à ce problème, on va suivre la règle : "Le meilleure des commentaires est un bon nom de méthode, classe ou variable".\\

\paragraph{Gain du traitement :}
En renommant nos méthodes, classe et variable pour que leurs noms représentent ce qu'elles contiennent ou font, on obtient un code avec beaucoup moins de commentaire mais qui devient bien plus intuitif et facile à comprendre.\\
Les commentaires restant ne sont plus la pour expliquer qu'est ce que contient une variable avec un nom peu évocateur tel que les variables temporaires qui s'appelle "temp".\\

\subsection{La duplication de code}
\paragraph{Problème :}
Ce problème peut arriver lorsque plusieurs développeurs travaillent en même temps sur le même projet. Il peut arriver qu'une fonctionnalité soit développer deux fois à deux endroits différent du code.\\
La duplication de code entraîne une réécriture plus longue de la fonctionnalité dupliqué car il faut la modifier à plusieurs endroits du code, et il est aussi possible d'oublier de modifier la fonctionnalité dans une des parties.\\
Pour supprimer la duplication de code il est conseillé d'utiliser la technique de refactoring "Extraction de méthode" qui va permettre d'extraire la méthode pour ensuite uniquement faire des appels de méthodes.\\

\paragraph{Gain du traitement :}
La suppression de la duplication de code nous permet de réduire la taille du code et donc de le simplifier.\\
Ce qui rend le code plus facile à modifier et faire évoluer.\\

\subsection{Les classes paresseuses}
\paragraph{Problème :}
La maintenance et la compréhension d'une classe sont des choses qui prennent du temps. Il est donc judicieux de faire en sorte de ne pas garder des classes qui ne sont plus pertinente et qui font perdre plus de temps qu'elles ne sont utiles.\\
Ici nous allons parler d'une classe qui ne contient que très peu de fonctionnalités et qui est devenu très petite avec le temps après d'autre refactoring.\\


Ce type de classe n'a plus grand intérêt à exister, il est donc intéressant de déplacer le peu de fonctionnalités restantes de la classe vers une autre classe puis de la supprimer.\\

\paragraph{Gain du refactoring :}
Supprimer des classes peu utile voir inutile permet de réduire la taille du code et de faciliter sa compréhension et sa maintenance.\\

\subsection{Les classes de données}
\paragraph{Problème :}
Une classe de donnée est une classe qui contient un regroupement de données qui permettent de faire des traitements si elles sont regroupées.\\
Ces classes de données sont utile mais peuvent rapidement perdre de leurs utilité lorsqu'elles sont utilisé uniquement comme un stockage de donnée. C'est à dire que la classe de données ne contient pas de fonctionnalité et ne contient que les variables avec des getters et setters.\\
Il est donc préférable de regrouper toutes les fonctionnalités lié à cette classe de données éparpiller dans tous le code pour les insérer comme des méthodes de la classe de données.\\ 

\paragraph{Gain du traitement :}
Regrouper les fonctionnalités va permettre de supprimer d'éventuels  duplication de code.\\
Et cela permet surtout de facilité la maintenance du code puisque toutes les fonctionnalités lié aux données sont regroupés dans la même classe.\\

\subsection{Le code mort}
\paragraph{Problème :}
Du code mort est un bout de code qui n'a plus aucune utilité au moment présent. Il peut s'agir de n'importe quoi comme une classe, une variable, une méthode ou même un paramètre.
Le soucis avec le code mort, c'est qu'une personne qui reprend du code ne va pas savoir que ce code n'a plus de raison d'exister et risque de perdre du temps en essayant de comprendre son utilité.\\

On peut aussi générer du code mort lorsque l'on développe de manière prévisionnel c'est à dire que l'on pense que dans le futur on aura besoin de cette fonctionnalité dans le futur.
On développe donc certaine fonctionnalité juste au cas où on en ai besoin.\\
Résultat la fonctionnalité n'a jamais été utilisé et on se retrouve avec du code mort.\\

La meilleure chose à faire avec du code mort c'est de le supprimer.\\

\paragraph{Gain du traitement :}
Supprimer du code mort permet de réduire la taille du code considérablement selon ce qui est supprimé mais aussi cela va rendre le code beaucoup plus simple à maintenir.\\




\chapter{Les différents type de refactoring}
Dans ce chapitre, je vais vous présenter des méthodes de refactoring qui permettent d'améliorer la qualité du code.\\

\section{Pattern de méthode composée}
L'un des grands ennemie des développeurs est de faire des méthodes trop longue qui sont difficilement compréhensible.
Une grande partie du refactoring est donc consacrée à la composition correcte des méthodes.\cite{ref5}\\

L'objectif de ce type de refactoring est de :\\
- rendre les méthodes facilement compréhensible.\\
- simplifier les méthodes en les brisants en plusieurs méthodes plus petites.\\
- supprimer la duplication de code.\\
- nommer proprement les variables, méthodes et paramètres pour comprendre leurs utilités au premier coup d'œil.\\
- pouvoir faire des tests plus facilement car les morceaux de méthodes peuvent être testés individuellement.\cite{ref6}

\newpage

\subsection{Extraction de méthode}
\paragraph{Présentation :} 
La technique d'extraction de méthode permet comme son nom l'indique, d'extraire des méthodes (ou fonction) du code. Car plus il y a de ligne dans une méthode plus il est difficile de comprendre ce que fait la méthode.\\
Il faut donc lorsque c'est possible extraire du code pour former d'autre méthode et simplifier le code.
\begin{center}
\includegraphics[scale=1]{Image/Extraction_Methode.png}\\
\itshape{Avant extraction de méthode}
\end{center}

\paragraph{Exemple :} 
Au dessus nous avons une méthode qui va afficher le prix d'un produit tout en calculant elle même le prix.\\
Si l'on applique l'extraction de méthode, on va obtenir l'exemple du bas, c'est à dire extraire la méthode de calcule du prix car on en aura surement besoin ailleurs. On remplace donc la calcule du prix dans la méthode affichagePrix par un appel à la méthode calculePrix.\\
\begin{center}
\includegraphics[scale=1]{Image/Extraction_Methode2.png}\\
\itshape{Après extraction de méthode}
\end{center}
\paragraph{Bénéfices :}
Pour que cette technique de refactoring soit la plus efficace, il faut absolument nommer ses méthodes et les paramètres de manière à comprendre très facilement qu'elle est sont but et que représente les paramètres. Le code est donc bien plus lisible.\\\\
A l'aide de cette méthode, on évite la duplication de code. Puisque dans l'exemple on aurait pu vouloir calculer le prix d'un produit dans une autre méthode, avec le code au dessus on aurait dupliqué le code pour calculer le prix d'un produit.\\\\
L'extraction de méthode nous permet aussi d'isoler les parties indépendantes du code. Cela est pratique lorsque l'on cherche un potentiel bug, on peut plus facilement tester toutes les méthodes du codes car elles sont toutes isolées les une des autres.

\paragraph{Technique inverse :}
La technique de refactoring Inline Method est l'exact opposé de l'extraction de méthode. Cette technique consiste à supprimé les méthodes jugées inutile qui sont très courtes ou qui sont plus facilement compréhensible par le code à l'intérieure de la méthode que par son nom. Cela à pour seul but de simplifier le code en diminuant le nombre de méthode dans le code.\\

\subsection{Extraction de variable}
\paragraph{Présentation :}
La technique d'extraction de variable permet de créer des variables claires qui nous permet de rendre des expressions complexe plus compréhensible.
Elle peut s'appliquer, par exemple, sur les conditions de if ou aussi des expressions arithmétiques sans résultats intermédiaires.

\begin{center}
\includegraphics[scale=1]{Image/Extraction_Variable.png}\\
\itshape{Avant extraction de variable}
\end{center}

\paragraph{Exemple :}
Au dessus, nous pouvons voir une fonction qui va faire quelque chose si l'état est done.
Si l'on applique l'extraction de variable, on obtient une variable isDone qui contient un boolean. Cette méthode nous permet de passer d'un code qui contient une expression peu lisible à un code avec une variable explicite.

\begin{center}
\includegraphics[scale=1]{Image/Extraction_Variable2.png}\\
\itshape{Après extraction de variable}
\end{center}

\paragraph{Bénéfices :}
Pour que le résultat de cette méthode soit optimal, il faut nommer efficacement les variables créées pour  qu'elles soient le plus lisible possible. Cela va permettre de produire un code plus lisible et qui contiendra moins de long commentaire pour expliquer les longues expressions.

\paragraph{Inconvénient :}
Le code va contenir beaucoup de variable mais cela est dérisoire comparé à la lisibilité du code qui est nettement améliorée.

\paragraph{Technique inverse :}
La technique Inline Temp va permettre de supprimer les variables superflue qui contienne uniquement le résultat d'une opération simple qui va être utilisé une seul fois. Cette technique n'a pas de vrai bénéfice dans cette état, en revanche elle peut être couplé avec la technique suivante.\\

\subsection{Remplacement des temporaires avec des méthodes}
\paragraph{Présentation :}
Le remplacement des temporaires avec des méthodes va comme son nom l'indique, remplacer des variables temporaires par le résultat de méthode. On va extraire le code des variables temporaire avec la technique Inline method puis les placer dans des méthodes.

\begin{center}
\includegraphics[scale=1]{Image/Remplacement_Temp_Methode.png}\\
\itshape{Avant remplacement du temporaire}
\end{center}

\paragraph{Exemple :}
Au dessus, nous pouvons voir que l'addition des deux paramètre est stocké dans une variable temporaire. Après le refactoring, la variable temporaire disparait et on obtient une méthode qui va s'occuper de faire l'addition à la place.

\begin{center}
\includegraphics[scale=1]{Image/Remplacement_Temp_Methode2.png}\\
\itshape{Après remplacement du temporaire}
\end{center}

\paragraph{Bénéfices :}
Le code est plus compréhensible grâce au nom de la méthode qui est explicite.\\
Si j'ai besoin plus tard dans mon code de faire une addition, j'ai une méthode que je peux réutiliser.\\

\newpage

\subsection{Diviser les variables temporaires}
\paragraph{Présentation :}
Parfois dans notre code, nous déclarons une variable temporaire où nous stockons un résultat quelconque. Puis plus tard, nous réutilisons cette même variable pour stocker un tout autre résultat n'ayant aucun rapport.
Cette technique a pour but de ne plus utiliser la même variable temporaire pour faire différentes choses et de nommer proprement chaque variable temporaire.

\begin{center}
\includegraphics[scale=1]{Image/Diviser_Temp.png}\\
\itshape{Avant division}
\end{center}

\paragraph{Exemple :}
On peut voir au dessus que je réutilise la variable temp pour faire à la fois une addition et une soustraction. Après le refactoring on obtient deux variable proprement nommées addition et soustraction.

\begin{center}
\includegraphics[scale=1]{Image/Diviser_Temp2.png}\\
\itshape{Après division}
\end{center}

\paragraph{Bénéfices :}
Le fait d'avoir chaque variable, méthode ou n'importe quelle composant qui a un unique but ou une responsabilité permet de faciliter grandement la maintenance du code. Puisque on peut modifier des parties du code sans que ça affecte une autre partie.\\
Cela permet aussi une meilleure relecture du code car on supprime les variables nommées temp ou value pour donner des noms facilement compréhensible.\\

\subsection{Supprimer les assignations aux paramètres}
\paragraph{Présentation :}
Ici le problème est semblable à celui de la division des variables temporaires, si on a un paramètre, on ne doit pas lui affecter d'autre valeur car cela modifie ce que représente le paramètre et on peut se perdre dans le code car on ne sait plus ce que contient ce paramètre.\\
Il vaut donc mieux déclarer une variable local plutôt que de modifier le paramètre.

\paragraph{Bénéfices :}
Comme dit plus haut, chaque éléments à une unique responsabilité et la maintenance du code est plus simple.\\

\subsection{Remplacement de méthode par des objets}
\paragraph{Présentation :}
Il nous arrive d'écrire des méthodes très longues qui possèdent beaucoup de variable qui sont extrêmement liées entre elles. On peut avec le refactoring créer une nouvelle classe qui va contenir la méthode ainsi que les anciennes variables locales en variable de classe.

\begin{center}
\includegraphics[scale=1]{Image/MethodeToObjet.png}\\
\itshape{Avant remplacement par l'objet \cite{ref5}}
\end{center}

\begin{center}
\includegraphics[scale=1]{Image/MethodeToObjet2.png}\\
\itshape{Après remplacement par l'objet \cite{ref5}}
\end{center}

\paragraph{Bénéfices :}
L'isolation d'une méthode longue dans sa propre classe permet d'empêcher le fait prenne de l'ampleur.\\
On peut aussi scinder cette méthode en sous-méthode sans "polluer" la classe d'origine avec des méthodes utilitaires.

\paragraph{Inconvénient :}
Cette méthode de refactoring nous fait créer une nouvelle classe et cela augmente la complexité global du programme.\\

\newpage

\section{Déplacement des fonctionnalités entre les objets}
Lorsque l'on code beaucoup de fonctionnalités dans un même programme, il arrive qu'au bout d'un moment, on se rendent compte que , par exemple, on a placé une fonctionnalité dans la mauvaise classe et qu'on ne sache pas comment faire pour la déplacer sans risquer de casser tout le code.\\
Or les méthodes de refactoring qui vont suivre seront du type à permettre le déplacement de fonctionnalités entre des classes en toute sécurité.\\


\subsection{Déplacement de méthode}
\paragraph{Présentation :}
Il se peut qu'à un instant t, vous vouliez déplacer une méthode dans un autre classe car cela vous arrange ou car cela aurait plus de sens. Dans ce cas la, on peut utiliser le refactoring pour déplacer cette méthode vers l'autre classe en toute sécurité.

\paragraph{Comment faire :}
Il faut commencer par regarder toutes les variables qui sont présente dans la classe et que la méthode utilise. Si c'est variable ne sont utilisé que par la méthode à déplacer, il faut les déplacer dans la nouvelle classe aussi.\\
En revanche si ces variables sont utilisées par d'autre méthode il est conseillé de déplacer aussi ces méthodes vers la nouvelle classe.
Ensuite, il faut s'assurer que toutes ces méthodes ne soit pas déclarer dans une classe mère ou fille.\\
Si toutes ces conditions sont réunis, on peut déclarer la ou les méthodes dans la nouvelle classe puis définir une méthode dans l'ancienne classe qui va appeler la nouvelle méthode.

\paragraph{Bénéfices :}
Cette méthode de refactoring nous permet d'obtenir une meilleure cohérence interne dans les classes.\\

\subsection{Extraction de classe}
\paragraph{Présentation :}
Il est possible, lorsque l'on développe quelque chose, de créer un classe qui en réalité fait le travail de deux classes. Il vaut mieux changer ça rapidement car cela risque d'empirer et d'obtenir une classe illisible. On peut alors appliquer une technique de refactoring pour extraire une classe d'une autre.

\begin{center}
\includegraphics[scale=1]{Image/Extraction_Classe.png}\\
\itshape{Avant extraction de la classe}
\end{center}

\begin{center}
\includegraphics[scale=1]{Image/Extraction_Classe2.png}\\
\itshape{Après extraction de la classe}
\end{center}

\paragraph{Comment faire :}
Il faut d'abord créer la nouvelle classe ainsi qu'une relation entre l'ancienne et la nouvelle classe.\\
Ensuite, il faut utiliser les méthodes de refactoring "Déplacement de méthode" et "Déplacement de variable" pour toutes les variables et méthodes à déplacer.

\paragraph{Bénéfices :}
Cette méthode de refactoring permet de respecter le principe de responsabilité unique.
Les classes respectant ce principe sont plus fiable et tolérante aux changements puisque si une classe peut faire plusieurs choses, la modification d'une fonctionnalité de la classe peut casser une autre fonctionnalité.

\paragraph{Technique inverse :}
La technique inverse consiste à supprimer les classes qui ont peut d'utilités. Cela permet de libérer de la mémoire.\\

\subsection{Cacher la délégation}
\paragraph{Présentation :}
Nous sommes dans le cas où une structure permet à un client d'appeler une méthode d'un objet A qui lui renvoie un objet B pour ensuite appeler une méthode de l'objet B pour obtenir l'information souhaitées. On obtient une chaîne d'appel or si l'on veut changer quelque chose à la relation entre A et B, cela aura pour conséquence de changer la chaîne d'appel côté client.\\
Pour éviter ça, il est préférable de cacher la délégation au yeux du client à l'aide de refactoring.

\begin{center}
\includegraphics[scale=0.7]{Image/Cacher_Delegation.png}\\
\itshape{Avant/Après le refactoring \cite{ref5}}
\end{center}

\paragraph{Comment faire :}
Il faut commencer par créer dans la classe serveur (la classe dont le client à un access direct) les mêmes méthodes qui sont dans la classe déléguer (la classe qui contient les informations dont le client à besoin).\\
Ensuite, il faut changer le code client pour qu'il appel la méthode de la classe serveur.\\
Si cela permet au client de ne plus avoir à utiliser la classe déléguer, on peut supprimer la méthode de la classe serveur qui renvoyait la classe déléguer.

\paragraph{Bénéfices :}
Le fait de cacher la délégation au client permet de lui cacher les relations entre les classes ce qui nous permet de changer le code de nos programmes plus simplement.

\paragraph{Inconvénient :}
A chaque fois, qu'une nouvelle fonctionnalité est ajoutées à la classe délégué, il faut alors créer une nouvelle méthode dans la classe serveur. Si ces changements arrivent souvent cela peut rapidement devenir pénible.

\paragraph{Technique inverse :}
Il existe donc une technique pour les cas où la classe délégué possède beaucoup trop de méthode.
La technique de suppression du "Middle Man".
Cette technique consiste simplement à créer une méthode qui renvoie la classe délégué pour éviter de devoir changer la classe serveur à chaque fois qu'une nouvelle fonctionnalité est ajouté à la classe délégué.\\


\newpage
\section{Organiser ses données}
Ce type de refactoring va permettre de mieux gérer les données des classes en dissociant les associations de classe pour les rendre plus portable et réutilisables.\\


\subsection{Auto Encapsulation des champs}
\paragraph{Présentation :}
Dans le cas d'une classe contenant des variables privées, il est préférable d'utiliser des getters et setters à l'intérieure même de la classe pour accéder aux variables.

\paragraph{Bénéfices :}
En accédant indirectement aux variables, on opte pour une approche plus flexible, cela nous permet par exemple de produire des opérations quand une variable est "set" ou "get". Cela peut être fait très facilement en modifiant simplement le getter et setter de la variable en question.
Utiliser les gettes et setters nous permet aussi de les redéfinir dans les sous-classes si un changement doit être fait dans les opérations de vérifications.\\

\subsection{Passer du stockage par valeur en référence}
\paragraph{Présentation :}
Nous pouvons stocker des objets par valeur ou par référence. Le premier nous permet d'avoir une image de l'objet à l'instant où il est sauvegardé et le deuxième stocke un "lien" qui nous permet d'accéder à l'objet et non pas une image.
Si lorsque nous créons un programme, nous stockons un objet qui ne change pas ou très peu dans le temps nous pouvons le stocker par valeur en revanche si à l'avenir cette objet vient à se modifier plus souvent, il sera nécessaire de le stoker par référence.

\paragraph{Bénéfices :}
Utiliser les références permet de posséder les informations les plus récentes à propos d'un objet. C'est à dire que si un objet est modifié à un moment, si quelqu'un possède une référence sur l'objet, il aura accès immédiatement au changement.

\paragraph{Inconvénient :}
L'inconvénient majeur de ce refactoring est qu'il est compliqué à mettre en place.

\paragraph{Technique inverse :}
Il est possible de faire le refactoring dans le sens inverse dans le cas où l'objet change très peu au fil du temps. Il ne vaut donc pas le coup de mettre en place une référence dans ce cas là.\\


\subsection{Remplacer les nombres magiques en constantes}
\paragraph{Présentation :}
Un nombre magique est un nombre qui n'est pas stocker dans une variable et qui apparait dans une équation sans qu'on ne connaisse sont utilité au premier coup d'œil. Il est très compliqué de modifier ces nombres magiques surtout s'ils apparaissent plusieurs fois dans le code.

\paragraph{Comment faire :}
La solution pour faire disparaître les nombres magiques et de rendre le code plus lisible est très simple. Il suffit de trouver toutes les occurrences de ces nombres magiques et de déclarer une constante qu'on utilisera à la place. Cette constante aura un nom adapté pour que l'on puisse comprendre rapidement ce qu'elle représente.

\paragraph{Bénéfices :}
Les constantes permettent de savoir facilement ce qu'elle représente.\\
Il est beaucoup plus simple de changer la valeur d'une constante plutôt que de chercher partout dans le code.\\

\subsection{Encapsulation de collection}
\paragraph{Présentation :}
Dans le cas de l'utilisation d'une collection, il faut avoir en tête qu'il ne s'agit pas d'une simple variable qui nécessite un getter et un setter. Il faut la gérer différemment et créer des méthodes spécifique pour la gestion de collection.

\paragraph{Comment faire :}
Pour traiter avec des collections, il faut un minimum de trois méthodes, la première étant la méthode "add". Cette méthode va permettre l'ajout d'un objet dans la collection en prenant uniquement l'objet à ajouter en paramètre.\\
La deuxième méthode est "remove", elle permet de supprimer un objet d'une collection en ne donnant que l'objet à effacer de la collection en paramètre.\\
La dernière est une simple méthode "get" qui va donner une copie de la collection pour que l'objet puisse être consulté sans pour autant pouvoir être modifié.

\paragraph{Bénéfices :}
Avec cette gestion de collection, on ne peut plus modifier une collection en récupérant l'objet à partir du getter.\\
Les règles, s'il en a, pour ajouter des objets dans la collection seront toujours respecter puisqu'il faudra impérativement passer par la méthode add ou remove pour modifier la collection.\\
Cela permet aussi de rendre l'utilisation de collection plus simple.\\

\subsection{Remplacer les Type Code}
\paragraph{Présentation :}
Les Type Code sont des champs qui peuvent contenir des valeurs fixe définie par le développeur pour représenter quelque chose.\\
Dans l'exemple ci-dessous, on a une classe qui représente une tâche à faire, et elle contient une variable qui va représenter son état qui peut être soit "TODO","ONGOING" ou "DONE". Ces trois états sont définie chacun par une valeur numérique.\\
Il existe trois type de refactoring qui permettent chacun de remplacer les Type Code par des alternatives plus avantageuses.

\begin{center}
\includegraphics[scale=1]{Image/TypeCode.png}\\
\itshape{Exemple de Type Code}
\end{center}

\paragraph{Remplacement par une classe :}
Il est possible de remplacer un Type Code par une classe de type Énumération.\\
Cela permet de ne plus utiliser de simple nombre qui ne sont pas forcément compréhensible à première vue alors que les énumérations sont facilement lisible.\\
Le typage à l'aide d'une énumération va permettre de ne plus se soucier de la valeur des Type Code (Est ce que le nombre rentré à bien une signification?) ce qui permet de faire moins de gestion sur ces valeur.

\begin{center}
\includegraphics[scale=1]{Image/TypeCodeClasse.png}\\
\itshape{Remplacement de Type Code à l'aide d'une classe}
\end{center}

\paragraph{Remplacement par une sous classe :}
On peut remplacer les Type Code par des sous classe. A l'aide de ce procédé nous pouvons écrire des méthodes ou créer des champs spécifique selon le type de l'objet. Cette méthode permet aussi de rajouter très facilement de nouveau "type" en créant simplement une nouvelle sous classe.
Il adhère aussi mieux au principe de responsabilité unique.\\
En revanche, le problème de cette approche est qu'on ne peut pas changer le type de l'objet facilement s'il venait à changer.\\
Il est possible de faire la technique inverse dans le cas où les sous classes diffère uniquement par les valeurs retour de les méthodes (ces valeurs étant des constantes). Garder des sous classes dans ce cas là, complexifie l'architecture pour un apport négligeable.

\begin{center}
\includegraphics[scale=1]{Image/TypeCode_SousClasse.png}\\
\itshape{Avant remplacement de Type Code à l'aide d'une sous classe}
\end{center}

\begin{center}
\includegraphics[scale=1]{Image/TypeCode_SousClasse2.png}\\
\itshape{Après remplacement de Type Code à l'aide d'une sous classe}
\end{center}

\paragraph{Remplacement par State/Strategy}
Cette méthode est une alternative à la précédente dans le cas où le type de l'objet est soumis à des changement pendant sa durée de vie. Cette méthode utilise le pattern State/Strategy. Comme la précédente, il est simple de rajouter une nouveau type si besoin sans avoir à modifier du code existant. L'exemple suivant est le même que le précédent.

\begin{center}
\includegraphics[scale=1]{Image/TypeCode_State.png}\\
\itshape{Après remplacement de Type Code à l'aide du pattern State/Strategy}
\end{center}


\newpage
\section{Simplifier les expressions conditionnels}
Dans les programmes, il n'est pas rare de trouver des expressions conditionnels qui possèdent une logique complexe avec beaucoup de condition. Ce type de refactoring va permettre de simplifier toutes ces expressions.\\



\subsection{Décomposer les expressions conditionnels}
\paragraph{Présentation :}
Il nous arrive souvent dans nos programmes, d'avoir des conditions regroupant plusieurs condition. Le résultat étant une condition assez complexe à comprendre sans commentaire pour l'expliquer. La solution à ce problème est de déplacer le calcule de ces conditions dans des méthodes.

\paragraph{Comment faire :}
Pour ce faire, il faut utiliser la méthode de refactoring d'extraction de méthode sur le bloc conditionnel pour obtenir un simple appel de méthode avec un nom compréhensible.

\paragraph{Bénéfices :}
Le bénéfice majeur de cette technique est de permettre une relecture et une maintenance du code simplifier.\\

\subsection{Remplacer les conditions avec du polymorphisme}
\paragraph{Présentation :}
Dans le cas où nous avons par exemple un switch qui va produire différent traitement selon le type d'un objet. Alors dans ce cas là, il sera intéressant de supprimer le switch pour produire des sous classes.

\begin{center}
\includegraphics[scale=1]{Image/ReplaceConditionalPoly.png}\\
\itshape{Avant refactoring \cite{ref5}}
\end{center}

\paragraph{Exemple :}
Dans l'exemple, on est passé d'un switch qui calculait la vitesse d'un oiseau selon son type dans la classe "Bird". A une classe abstraite qui nécessite la redéfinition de la méthode de calcule de vitesse pour chaque sous classe soit obliger de la redéfinir.

\begin{center}
\includegraphics[scale=1]{Image/ReplaceConditionalPoly2.png}\\
\itshape{Après refactoring \cite{ref5}}
\end{center}

\paragraph{Bénéfices :}
Dans cette exemple cela permettrait de rajouter des types d'oiseau simplement en recréant une sous classe sans avoir à modifier une méthode déjà existante.\\
On évite aussi des conditions switch ou autre très longue du fait qu'il y aurait beaucoup de type à gérer.\\

\subsection{Introduire des assertions}
\paragraph{Présentation :}
Une assertion est une condition qui doit être évaluer à vrai pour que le programme puisse continuer à fonctionner. Si une assertion renvoie faux alors le programme s'arrête immédiatement.
Dans le cadre d'un programme qui nécessite absolument une variable, un objet ou n'importe quoi pour pouvoir fonctionner. Même si cette donnée est censé être présente à ce moment du programme, il est plus sure de placer une assertion pour vérifier que cette donnée existe bien au moment venu.

\paragraph{Bénéfices :}
Placer des assertions permet de détecter des erreurs et permet d'arrêter des programmes qui risque de faire des dégâts si on les laisse continuer alors que quelque chose ne c'est pas déroulé comme prévue.
Les assertions sont la plus part du temps utilisées dans les tests unitaires mais elles peuvent être utilisé dans nos programmes et se révéler très utiles.\\

\newpage
\section{Simplifier les appels de méthode}
Ces techniques de refactoring ont pour but de simplifier l'appel de méthode ainsi que de rendre l'appel de méthode plus facile à comprendre.\\



\subsection{Renommer une méthode}
\paragraph{Présentation :}
Commençons cette partie par quelque chose de simple mais terriblement efficace, les noms de méthode.\\
Lorsque l'on code une méthode, il faut lui donner un nom qui permet de comprendre ce que la méthode fait sans avoir à lire une seul ligne de code. Il s'agit d'une règle de base en programmation mais elle n'est pas toujours respectée.

\paragraph{Bénéfices :}
L'avantage de bien nommer une méthode est d'améliorer la relecture de son propre code ainsi que grandement faciliter la futur maintenance du code par quelqu'un d'autre.\\

\subsection{Séparer les requêtes de questionnement et de modification}
\paragraph{Présentation :}
Une méthode doit avoir une seul tâche à accomplir et non pas plusieurs. Et surtout si cette même méthode mêle opération de lecture et d'écriture.
Dans cette méthode de refactoring, nous appliquons le pattern de "Command and Query Responsibility Segregation" qui nous dis qu'il faut séparer les opérations de lecture et d'écriture.
Pour appliquer ce refactoring il faut simplement séparer la méthode en deux pour obtenir deux nouvelles méthodes, une qui récupère des données et l'autre qui modifie des données.

\paragraph{Bénéfices :}
Cette technique permet évidemment de pouvoir faire des lectures sans avoir forcement à modifier une donnée.\\
Le pattern "Command and Query Responsibility Segregation" nous permet de maximiser les performances, l'évolutivité ainsi que la sécurité.\\

\subsection{Méthode paramétrée}
\paragraph{Présentation :}
Parfois, il nous peut nous arriver d'écrire deux méthodes assez similaire qui on un but commun mais qui le traite avec des opérations ou valeurs qui diffèrent. Dans un cas similaire, il est conseillé de créer une seul méthode qui va regrouper les deux et prendre un paramètre pour savoir quel traitement appliquer.\\

\begin{center}
\includegraphics[scale=1]{Image/Methode_Parametre.png}\\
\itshape{Exemple de méthode paramétrée \cite{ref8}}
\end{center}

\paragraph{Bénéfices :}
On obtient une seul méthode au lieu de deux très similaire, ce qui permet la suppression de la duplication de code.\\
A l'avenir, on a plus besoin de créer d'autre méthode si une nouvelle version de la méthode est nécessaire comme une augmentation de sept pourcents en reprenant l'exemple.\\

\paragraph{Technique inverse :}
il existe une technique qui revient plus ou moins a faire l'inverse. Il s'agit de la méthode de remplacement de paramètre avec des méthodes explicites.\\
Dans ce cas, on a une méthode qui va pouvoir faire plusieurs traitement différent qui n'ont rien à avoir entre eux. La méthode sait qu'elle traitement faire grâce à un des paramètres.\\
On peut avoir une méthode "setValue" sui prend en paramètre une chaîne de caractère et un valeur. Si la chaîne vaut "prix" alors la méthode sauvegarde la valeur dans le prix et si la chaîne vaut "poids" alors la méthode va enregistrer la valeur dans la variable poids.\\
Il serait donc préférable de faire du refactoring et de séparer les deux méthodes pour obtenir une méthode "setPrix" et une autre "setPoids". Ce qui rend le programme plus clair et intuitif.\\

\subsection{Conserver l'objet entier}
\paragraph{Présentation :}
Lorsqu'une méthode a besoin de variable qui sont contenus dans un objet, il est préférable d'envoyer l'objet entier en paramètre plutôt que d'envoyer uniquement les variables de l'objet.

\paragraph{Bénéfices :}
Le résultat est un code plus lisible car on a plus qu'un paramètre qui est l'objet contenant tous les anciens paramètres.\\
Un autre avantage est que si la méthode doit évoluer et a besoin d'une autre variable de l'objet, pas besoin d'aller modifier tous le code pour modifier l'appel de la méthode en rajoutant le nouveau paramètre. Cela rend le code plus facile à faire évoluer.\\

\subsection{Ajouter des objets en paramètre}
\paragraph{Présentation :}
Dans nos programmes, il peut arriver que l'on écrive plusieurs méthode utilisant exactement les mêmes paramètre. Le problème étant une duplication de paramètre ainsi que potentiellement une duplication de code à l'intérieur des méthodes en traitant les paramètres.\\
Dans ce cas, nous avons la possibilité de créer un objet qui va contenir les paramètres ainsi que des méthodes qui vont s'occuper du traitement de ces paramètres.\\

\begin{center}
\includegraphics[scale=1]{Image/Ajout_Objet_Parametre.png}\\
\itshape{Exemple de transformation de paramètre en objet \cite{ref8}}
\end{center}

\paragraph{Bénéfices :}
L'avantage principal de cette méthode est de supprimer la duplication de code généré par le traitement identique des paramètres dans plusieurs méthodes.\\
Les paramètres sont aussi plus lisible du fait qu'il ne reste plus qu'un seul objet avec un nom adapté pour une compréhension simple et efficace.\\
En revanche, ce refactoring n'est pas utile s'il ne sert uniquement à stocker les paramètres sans y ajouter des méthodes de traitement.\\

\subsection{Remplacer les constructeurs par des méthode Factory}
\paragraph{Présentation :}
Plaçons nous dans un cas où on veut que notre constructeur ne soit pas accessible par l'extérieur.
On va alors devoir utiliser cette méthode de refactoring qui se base sur le pattern de factory.

\paragraph{Comment faire :}
Pour ce faire, il faut simplement créer une nouvelle méthode avec un nom adapté comme "createNomObjet", cette méthode va alors appelé elle même le constructeur et renvoyer une instance de l'objet demandé.

\paragraph{Bénéfices :}
Les méthodes de type Factory ne renvoie pas forcément une instance de l'objet dont elle fait partie. Cela peut avoir un grand avantage s'il faut renvoyer un sous classe car on peut utiliser cette méthode pour faire un traitement à l'aide de paramètre pour décider qu'elle sous classe renvoyer.\\
La méthode Factory peut avoir un nom plus approprié que celui d'un constructeur pour comprendre ce qu'elle fait.\\
On peut aussi l'utiliser pour renvoyer des instances déjà existante(Singleton), ce qui n'est pas possible avec un constructeur.\\


\subsection{Remplacer les codes d'erreurs par des exceptions}
\paragraph{Présentation :}
Aujourd'hui, les codes d'erreurs sont quelques choses  qu'il ne vaut mieux plus utiliser car il existe une classe spécialement faites pour la gestion d'erreurs, les exceptions.\\
L'utilisation des exceptions permet de détecter et de traiter les erreurs qui peuvent se produire pendant l'exécution du code.\\

\begin{center}
\includegraphics[scale=1]{Image/ThrowException.png}\\
\itshape{Remplacement de code d'erreur par une exception \cite{ref8}}
\end{center}

\paragraph{Bénéfices :}
L'utilisation des exceptions nous permet principalement d'éviter à faire de la gestion d'erreur à travers les codes d'erreurs.\\
Il est plus rapide de se rendre compte que quelque chose c'est mal passé si une exception est levée.\\
Les codes d'erreurs ne peuvent pas être utilisé dans les constructeurs alors que les exceptions le peuvent.\\
On peut aussi créer nos propres exceptions pour qu'elles fassent un traitement particulier.\\

\paragraph{Méthode alternative :}
Les exceptions sont des objets qui doivent être utilisées pour gérer les comportements irréguliers provoqués par des erreurs inattendu.\\
Il ne faut pas utilisé les exceptions à la place de simple test.\\

\begin{center}
\includegraphics[scale=0.75]{Image/ExceptionTest.png}\\
\itshape{Remplacement d'exception par un test \cite{ref5}}
\end{center}

\newpage
\section{Faire face à la généralisation}
Dans cette partie, nous allons étudier des techniques permettant de déplacer des fonctionnalités dans la hiérarchie d'héritage de classes, à la création de nouvelles classes et d'interfaces.\\



\subsection{Remonter les variables et méthodes}
\paragraph{Présentation :}
Nous allons commencer par un cas basique, si nous avons une super classe ainsi que deux sous classes qui hérite de la super classe, et que les deux sous classes possèdent un attribut ou une méthode commune que ne possède pas la super classe alors il sera intéressant de déplacer cette variable ou méthode dans la super classe.\\

\paragraph{Bénéfices :}
Ce refactoring élimine de la duplication de code que ce soit dans la définition d'une variable ou méthode ainsi que pour le corps de la méthode.\\
Dans le cas de la méthode cela permet de ne modifier que la méthode présente dans la super classe en cas de changement au lieu de devoir passer dans toutes les sous classes.\\

\paragraph{Technique inverse :}
Il existe évidemment une technique pour descendre les champs et méthode.\\
Que ce soit pour les variables ou les méthodes, il est préférable de déplacer un champs ou une méthode d'une super classe dans une sous classe si ce dit champs ou méthode n'est utilisé que dans cette même sous classe.\\
Cela permet de rentre le code plus compréhensible et améliore la cohérence interne de la classe.\\


\subsection{Extraire une super classe}
\paragraph{Présentation :}
Si l'on a deux classes qui possèdent des champs ou des méthodes communes, alors il serait intéressant de créer une super classe dont les deux classes hériteraient.\\

\paragraph{Bénéfices :}
On supprime donc de la duplication de code.\\
En revanche cette méthode de refactoring ne peut pas être utilisé dans le cas où l'une des deux classes possèdent déjà une super classe.\\

\subsection{Créer des méthodes Template}
\paragraph{Présentation :}
Il nous est déjà arriver d'avoir deux sous classe qui possèdent une méthode assez similaire qui déroule un algorithme possédant les mêmes étapes mais avec des valeurs changeante.\\
Il y a alors un moyen de créer un template de la méthode dans la super classe tout en laissant l'implémentation qui diffère aux sous classe.\\

\begin{center}
\includegraphics[scale=0.75]{Image/Template.png}\\
\itshape{Avant mise en place du template \cite{ref5}}
\end{center}

\paragraph{Exemple :}
Dans cette exemple, on peut voir au dessus qu'on a deux sous classe qui possèdent une méthode permettant de calculer le montant d'une facture.\\
Les deux méthodes n'utilisent pas les mêmes valeurs pour le calcule mais en revanche le calcule se résume dans les deux cas à l'addition du tarif de base additionner au taxe.\\
On peut donc voir en dessous que la solution est de créer remonter la méthode de calcule du montant de la facture dans la super classe qui va renvoyer l'addition du prix de base additionner à celui des taxes.\\
Ces prix là seront calculer à l'aide de deux nouvelles méthode qui seront redéfinie dans les sous classes.\\

\begin{center}
\includegraphics[scale=0.75]{Image/Template2.png}\\
\itshape{Après mise en place du template \cite{ref5}}
\end{center}

\paragraph{Bénéfices :}
Les templates nous permettent de supprimer de la duplication de code même s'il ne s'agit pas exactement du même code.\\
Cela peut aussi nous faire gagner du temps dans le cas où il faut créer une nouvelle sous classe, on aura juste dans l'exemple à redéfinir le calcule du prix de base et des taxes.\\

\subsection{Remplacer l'héritage par de la délégation}
\paragraph{Présentation :}
Ici, nous avons une classe B qui hérite d'une classe A et qui n'utilise qu'une petite portion des méthodes de sa super classe.\\
Il serait judicieux de créer un champs dans B pour stocker A et ensuite de créer des méthodes pour déléguer le travail à la classe A.

\paragraph{Bénéfices :}
Cela permet à la classe B de posséder uniquement les méthodes qu'elle utilise et non pas toutes les méthodes de la classe A qu'elle n'utilise pas.

\paragraph{Technique inverse :}
Il existe aussi la technique inverse, c'est à dire remplacer la délégation par de l'héritage dans le cas où la classe B utilise beaucoup de méthode de la classe A.
Dans ce cas il est préférable de privilégier l'héritage ce qui permet de réduire la taille du code due à la suppression de toutes les méthodes de délégation.\\

\chapter{Outils de refactoring}
\section{Fonctionnalités d'IDE}
Dans cette partie, je vais vous présenter les fonctionnalités de refactoring que l'IDE Eclipse propose à ces utilisateurs.


\section{AutoRefactor}
\subsection{Présentation du projet}
Le projet AutoRefactor a été lancé par Jean-Noël Rouvignac. Il a décidé de se lancer dans se projet car il était fatigué de devoir prendre trop de temps pour appliquer les mêmes nettoyages de code encore et encore. L'objectif de ce projet est de faciliter la maintenance, moderniser le code, rendre le code plus léger et compacte et augmenter les performances des programmes. Il a commencé à travailler sur les expressions rationnelles pour retravailler toute la base du code, mais les faux positifs étaient trop nombreux.\cite{ref7} Il a ensuite créé un greffon Eclipse (AutoRefactor) qui utilise  l'API des Java Development Tools (Eclipse JDT) qui est l'API que eclipse utilise pour faire du refactoring.\\
Une première release du produit est sortie le 22 mars 2015 et plus récemment la version 1.2 est sortie (30 juin 2018).

\subsection{Fonctionnement du programme}
Je vais maintenant vous présenter un algorithme simplifié de comment fonctionne AutoRefactor.

Le développeur choisi les règles de refactoring à appliquer puis le greffon prend la liste des refactorings.

1) Le fichier Java à analyser est parsé et produit un arbre syntaxique abstrait.\\

2) Pour chaque refactoring :\\
\tabto{0.8cm} 1) Cherche des opportunités de refactoring en visitant l'abre syntaxique abstrait.\\
\tabto{0.8cm} 2) Génère les réécritures de code lorsqu'une  opportunité de refactoring a été identifiée.\\

3) Lorsque tout l'arbre syntaxique abstrait a été visité, si des réécriture de code ont été générées :\\
\tabto{0.8cm} 1) Alors, toutes les réécritures de code générées sont appliquées sur le fichier.\\
\tabto{0.8cm} 2) Le fichier est sauvegardé.\\
\tabto{0.8cm} 3) Boucle vers 1.\\
\tabto{0.8cm} 4) Sinon, fin : il n'y a plus de refactoring possibles sur ce fichier.\\

Actuellement, tous les refactorings implémentés font du filtrage par motif et travaillent fichiers par fichiers.
\subsection{Fonctionnalités}
s

\subsection{Objectif futur}
Jean-Noël Rouvignac a pour objectif futur de réussir à construire des graphes de flot de contrôle pour pouvoir les analyser. Ceci lui permettrait d'écrire des refactorings comprenant les chemins d'exécution du code, comme le ferait un développeur qui lirait du code. En particulier, il deviendrait possible de réduire la portée des variables, comprendre quels chemins d'exécution du code sont morts (impossibles à atteindre).\cite{ref7}\\
Il aimerait développer une fonctionnalité d'extraction automatique de méthode pour simplifier les longues méthodes.



\section{Les graphes de flots de contrôle}
Actuellement, les flots de contrôle ne sont pas utilisés pour faire du refactoring.





\bibliographystyle{plain}
\bibliography{bibliographie}
\end{document}
