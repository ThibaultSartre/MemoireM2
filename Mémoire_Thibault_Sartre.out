\BOOKMARK [0][-]{chapter.1}{Introduction}{}% 1
\BOOKMARK [1][-]{section.1.1}{Remerciements}{chapter.1}% 2
\BOOKMARK [1][-]{section.1.2}{Introdution}{chapter.1}% 3
\BOOKMARK [0][-]{chapter.2}{Pourquoi faire du refactoring ?}{}% 4
\BOOKMARK [1][-]{section.2.1}{Bloaters}{chapter.2}% 5
\BOOKMARK [2][-]{subsection.2.1.1}{M\351thode trop longue}{section.2.1}% 6
\BOOKMARK [2][-]{subsection.2.1.2}{Grande classe}{section.2.1}% 7
\BOOKMARK [2][-]{subsection.2.1.3}{L'obsession des types primitifs}{section.2.1}% 8
\BOOKMARK [2][-]{subsection.2.1.4}{Longue liste de param\350tres}{section.2.1}% 9
\BOOKMARK [2][-]{subsection.2.1.5}{Agr\351gat de donn\351es}{section.2.1}% 10
\BOOKMARK [1][-]{section.2.2}{Abus du principe orientation objet}{chapter.2}% 11
\BOOKMARK [2][-]{subsection.2.2.1}{La structure switch}{section.2.2}% 12
\BOOKMARK [2][-]{subsection.2.2.2}{H\351ritage refus\351}{section.2.2}% 13
\BOOKMARK [1][-]{section.2.3}{Modification complexe}{chapter.2}% 14
\BOOKMARK [2][-]{subsection.2.3.1}{Changement Divergent}{section.2.3}% 15
\BOOKMARK [2][-]{subsection.2.3.2}{Chirurgie au fusil}{section.2.3}% 16
\BOOKMARK [1][-]{section.2.4}{Les choses dispensables}{chapter.2}% 17
\BOOKMARK [2][-]{subsection.2.4.1}{Les commentaires}{section.2.4}% 18
\BOOKMARK [2][-]{subsection.2.4.2}{La duplication de code}{section.2.4}% 19
\BOOKMARK [2][-]{subsection.2.4.3}{Les classes paresseuses}{section.2.4}% 20
\BOOKMARK [2][-]{subsection.2.4.4}{Les classes de donn\351es}{section.2.4}% 21
\BOOKMARK [2][-]{subsection.2.4.5}{Le code mort}{section.2.4}% 22
\BOOKMARK [0][-]{chapter.3}{Les diff\351rents types de refactoring}{}% 23
\BOOKMARK [1][-]{section.3.1}{Pattern de m\351thode compos\351e}{chapter.3}% 24
\BOOKMARK [2][-]{subsection.3.1.1}{Extraction de m\351thode}{section.3.1}% 25
\BOOKMARK [2][-]{subsection.3.1.2}{Extraction de variable}{section.3.1}% 26
\BOOKMARK [2][-]{subsection.3.1.3}{Remplacement des temporaires avec des m\351thodes}{section.3.1}% 27
\BOOKMARK [2][-]{subsection.3.1.4}{Diviser les variables temporaires}{section.3.1}% 28
\BOOKMARK [2][-]{subsection.3.1.5}{Supprimer les assignations aux param\350tres}{section.3.1}% 29
\BOOKMARK [2][-]{subsection.3.1.6}{Remplacement de m\351thode par des objets}{section.3.1}% 30
\BOOKMARK [1][-]{section.3.2}{D\351placement des fonctionnalit\351s entre les objets}{chapter.3}% 31
\BOOKMARK [2][-]{subsection.3.2.1}{D\351placement de m\351thode}{section.3.2}% 32
\BOOKMARK [2][-]{subsection.3.2.2}{Extraction de classe}{section.3.2}% 33
\BOOKMARK [2][-]{subsection.3.2.3}{Cacher la d\351l\351gation}{section.3.2}% 34
\BOOKMARK [1][-]{section.3.3}{Organiser ses donn\351es}{chapter.3}% 35
\BOOKMARK [2][-]{subsection.3.3.1}{Auto Encapsulation des champs}{section.3.3}% 36
\BOOKMARK [2][-]{subsection.3.3.2}{Passer du stockage par valeur en r\351f\351rence}{section.3.3}% 37
\BOOKMARK [2][-]{subsection.3.3.3}{Remplacer les nombres magiques en constantes}{section.3.3}% 38
\BOOKMARK [2][-]{subsection.3.3.4}{Encapsulation de collection}{section.3.3}% 39
\BOOKMARK [2][-]{subsection.3.3.5}{Remplacer les Type Code}{section.3.3}% 40
\BOOKMARK [1][-]{section.3.4}{Simplifier les expressions conditionnelles}{chapter.3}% 41
\BOOKMARK [2][-]{subsection.3.4.1}{D\351composer les expressions conditionnelles}{section.3.4}% 42
\BOOKMARK [2][-]{subsection.3.4.2}{Remplacer les conditions avec du polymorphisme}{section.3.4}% 43
\BOOKMARK [2][-]{subsection.3.4.3}{Introduire des assertions}{section.3.4}% 44
\BOOKMARK [1][-]{section.3.5}{Simplifier les appels de m\351thode}{chapter.3}% 45
\BOOKMARK [2][-]{subsection.3.5.1}{Renommer une m\351thode}{section.3.5}% 46
\BOOKMARK [2][-]{subsection.3.5.2}{S\351parer les requ\352tes de questionnement et de modification}{section.3.5}% 47
\BOOKMARK [2][-]{subsection.3.5.3}{M\351thode param\351tr\351e}{section.3.5}% 48
\BOOKMARK [2][-]{subsection.3.5.4}{Conserver l'objet entier}{section.3.5}% 49
\BOOKMARK [2][-]{subsection.3.5.5}{Ajouter des objets en param\350tre}{section.3.5}% 50
\BOOKMARK [2][-]{subsection.3.5.6}{Remplacer les constructeurs par des m\351thode Factory}{section.3.5}% 51
\BOOKMARK [2][-]{subsection.3.5.7}{Remplacer les codes d'erreurs par des exceptions}{section.3.5}% 52
\BOOKMARK [1][-]{section.3.6}{Faire face \340 la g\351n\351ralisation}{chapter.3}% 53
\BOOKMARK [2][-]{subsection.3.6.1}{Remonter les variables et m\351thodes}{section.3.6}% 54
\BOOKMARK [2][-]{subsection.3.6.2}{Extraire une super classe}{section.3.6}% 55
\BOOKMARK [2][-]{subsection.3.6.3}{Cr\351er des m\351thodes Template}{section.3.6}% 56
\BOOKMARK [2][-]{subsection.3.6.4}{Remplacer l'h\351ritage par de la d\351l\351gation}{section.3.6}% 57
\BOOKMARK [0][-]{chapter.4}{Outils de refactoring}{}% 58
\BOOKMARK [1][-]{section.4.1}{Fonctionnalit\351s d'IDE}{chapter.4}% 59
\BOOKMARK [1][-]{section.4.2}{AutoRefactor}{chapter.4}% 60
\BOOKMARK [2][-]{subsection.4.2.1}{Pr\351sentation du projet}{section.4.2}% 61
\BOOKMARK [2][-]{subsection.4.2.2}{Fonctionnement du programme}{section.4.2}% 62
\BOOKMARK [2][-]{subsection.4.2.3}{Fonctionnalit\351s}{section.4.2}% 63
\BOOKMARK [2][-]{subsection.4.2.4}{Objectif futur}{section.4.2}% 64
\BOOKMARK [1][-]{section.4.3}{Les graphes de flots de contr\364le}{chapter.4}% 65
\BOOKMARK [2][-]{subsection.4.3.1}{Qu'est ce que c'est ?}{section.4.3}% 66
\BOOKMARK [2][-]{subsection.4.3.2}{Est-il utilisable pour faire du refactoring ?}{section.4.3}% 67
\BOOKMARK [2][-]{subsection.4.3.3}{Exemple d'utilisation possible d'un graphe de flots de contr\364le dans le refactoring}{section.4.3}% 68
\BOOKMARK [0][-]{chapter.5}{Conclusion}{}% 69
